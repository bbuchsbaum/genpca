diff --git a/R/gmd_cache.R b/R/gmd_cache.R
new file mode 100644
index 0000000..e3c2d1a
--- /dev/null
+++ b/R/gmd_cache.R
@@ -0,0 +1,62 @@
+#' @title Internal cache for GMD factorizations
+#' @keywords internal
+.gmd_cache <- new.env(parent = emptyenv())
+
+#' @keywords internal
+.digest_dense_matrix <- function(M) {
+  # Round to stabilize digest against tiny numeric jitter
+  digest::digest(list(dim = dim(M), data = round(as.numeric(M), 8)))
+}
+
+#' @keywords internal
+.digest_sparse_matrix <- function(M) {
+  # Use slots to avoid densifying
+  stopifnot(inherits(M, "sparseMatrix"))
+  digest::digest(list(dim = M@Dim, i = M@i, p = M@p, x = round(M@x, 8)))
+}
+
+#' @title Get (and cache) a *lower* Cholesky factor for a dense SPD matrix
+#' @param A numeric or dense Matrix (SPD). If sparse, falls back to dense.
+#' @return a base numeric matrix L (lower triangular) with A = L %*% t(L)
+#' @keywords internal
+get_chol_lower_dense <- function(A) {
+  if (!inherits(A, "Matrix")) A <- Matrix::Matrix(A, sparse = FALSE)
+  if (Matrix::isSparse(A)) A <- methods::as(A, "denseMatrix")
+  key <- paste0("L_", .digest_dense_matrix(A))
+  if (exists(key, envir = .gmd_cache, inherits = FALSE)) {
+    return(get(key, envir = .gmd_cache, inherits = FALSE))
+  }
+  L <- t(chol(Matrix::as.matrix(A)))  # base::chol returns upper by default
+  assign(key, L, envir = .gmd_cache)
+  L
+}
+
+#' @title Optionally clear the cache
+#' @keywords internal
+gmd_clear_cache <- function() {
+  rm(list = ls(envir = .gmd_cache, all.names = TRUE), envir = .gmd_cache)
+  invisible(TRUE)
+}
+
diff --git a/R/gmd_fast.R b/R/gmd_fast.R
index bc3e0e1..0d7e0a2 100644
--- a/R/gmd_fast.R
+++ b/R/gmd_fast.R
@@ -1,41 +1,125 @@
 #' Fast generalized matrix decomposition (dense/sparse dispatch)
 #' @param X numeric matrix (n x p)
 #' @param Q,R constraints (weights/metrics) for rows/cols
 #' @param k number of components
 #' @param tol tolerance
+#' @param topk logical; use top-k symmetric eigen when available (ARPACK). Defaults to TRUE.
+#' @param cache logical; cache Cholesky factors across calls when dense. Defaults to TRUE.
 #' @export
-gmd_fast_cpp <- function(X, Q, R, k, tol = 1e-8) {
+gmd_fast_cpp <- function(X, Q, R, k, tol = 1e-8, topk = TRUE, cache = TRUE) {
   if (!inherits(Q, "Matrix")) Q <- Matrix::Matrix(Q, sparse = FALSE)
   if (!inherits(R, "Matrix")) R <- Matrix::Matrix(R, sparse = FALSE)
 
   # coerce symmetric dense forms that trip Rcpp
   if (inherits(Q, "dsyMatrix")) Q <- methods::as(Q, "dgeMatrix")
   if (inherits(R, "dsyMatrix")) R <- methods::as(R, "dgeMatrix")
 
-  if (Matrix::isSparse(Q) || Matrix::isSparse(R)) {
-    Q <- methods::as(Q, "dgCMatrix")
-    R <- methods::as(R, "dgCMatrix")
-    return(gmd_fast_cpp_sp(X, Q, R, k, tol))
-  } else {
-    return(gmd_fast_cpp_dn(X, as.matrix(Q), as.matrix(R), k, tol))
-  }
+  n <- nrow(X); p <- ncol(X)
+  primal <- (p <= n)  # use primal when small side is p
+
+  # ---- choose path and apply caching for dense constraints ----
+  if (primal) {
+    if (!Matrix::isSparse(R) && isTRUE(cache)) {
+      L_R <- get_chol_lower_dense(R)
+      if (Matrix::isSparse(Q)) {
+        res <- gmd_fast_cpp_primal_sp(X, methods::as(Q, "dgCMatrix"), L_R, k, tol, topk)
+      } else {
+        res <- gmd_fast_cpp_primal_dn(X, as.matrix(Q), L_R, k, tol, topk)
+      }
+    } else {
+      # fall back to non-cached path
+      if (Matrix::isSparse(Q) || Matrix::isSparse(R)) {
+        res <- gmd_fast_cpp_sp(X, methods::as(Q, "dgCMatrix"), methods::as(R, "dgCMatrix"), k, tol, topk)
+      } else {
+        res <- gmd_fast_cpp_dn(X, as.matrix(Q), as.matrix(R), k, tol, topk)
+      }
+    }
+  } else {
+    # dual path (n < p): cache Cholesky for Q when dense
+    if (!Matrix::isSparse(Q) && isTRUE(cache)) {
+      L_Q <- get_chol_lower_dense(Q)
+      if (Matrix::isSparse(R)) {
+        res <- gmd_fast_cpp_dual_sp(X, L_Q, methods::as(R, "dgCMatrix"), k, tol, topk)
+      } else {
+        res <- gmd_fast_cpp_dual_dn(X, L_Q, as.matrix(R), k, tol, topk)
+      }
+    } else {
+      if (Matrix::isSparse(Q) || Matrix::isSparse(R)) {
+        res <- gmd_fast_cpp_sp(X, methods::as(Q, "dgCMatrix"), methods::as(R, "dgCMatrix"), k, tol, topk)
+      } else {
+        res <- gmd_fast_cpp_dn(X, as.matrix(Q), as.matrix(R), k, tol, topk)
+      }
+    }
+  }
+
+  # Name outputs like multivarious
+  k_use <- length(res$d)
+  pcs <- paste0("PC", seq_len(k_use))
+  colnames(res$u) <- pcs
+  colnames(res$v) <- pcs
+  names(res$d) <- pcs
+  res
 }
 
diff --git a/src/gmd_fast.cpp b/src/gmd_fast.cpp
index 0b9f7d2..5bd9c03 100644
--- a/src/gmd_fast.cpp
+++ b/src/gmd_fast.cpp
@@ -1,158 +1,356 @@
 // Copyright (c) 2025 genpca contributors
 #include <RcppArmadillo.h>
 // [[Rcpp::depends(RcppArmadillo)]]
 
-// Solve generalized PCA via eigen on (X^T Q X, R), return top-k.
-// Templated on Q and R to support arma::mat and arma::sp_mat.
-template <typename MatQ, typename MatR>
-Rcpp::List gmd_fast_impl(const arma::mat& X,
-                         const MatQ& Q,
-                         const MatR& R,
-                         const int k,
-                         const double tol) {
-  const int p = (int)X.n_cols;
-  const int k_use = std::min(k, p);
-
-  // A = X^T Q X
-  arma::mat A = X.t() * (Q * X);
-
-  // Cholesky of R (must be SPD). Use lower-triangular L: R = L L^T
-  arma::mat Rdense(R);
-  arma::mat L;
-  if (!arma::chol(L, Rdense, "lower")) {
-    Rcpp::stop("Cholesky of R failed (R not SPD?).");
-  }
-  arma::mat Linv = arma::inv(arma::trimatl(L));
-
-  // Reduce to standard symmetric eigenproblem: M = L^{-1} A L^{-T}
-  arma::mat M = Linv * A * Linv.t();
-
-  arma::vec eval;
-  arma::mat Z;
-  if (!arma::eig_sym(eval, Z, M)) {
-    Rcpp::stop("eig_sym failed on transformed problem.");
-  }
-
-  // Take top-k eigenpairs
-  arma::uvec ord = arma::sort_index(eval, "descend");
-  ord = ord.head(k_use);
-  arma::vec lam = eval.elem(ord);
-  arma::mat Zk  = Z.cols(ord);
-
-  // Back-transform generalized eigenvectors: v = L^{-T} z
-  arma::mat V = Linv.t() * Zk;
-
-  // singular values are sqrt(lambda) (clamp negatives due to numeric noise)
-  lam.transform( [tol](double v){ return (v > tol) ? std::sqrt(v) : 0.0; } );
-
-  // U = X V / d
-  arma::mat U = X * V;
-  for (int i = 0; i < k_use; ++i) {
-    double d = lam(i);
-    if (d > tol) U.col(i) /= d; else U.col(i).zeros();
-  }
-
-  // Q-orthonormalize U (modified Gram-Schmidt under Q)
-  for (int j = 0; j < k_use; ++j) {
-    for (int i = 0; i < j; ++i) {
-      double alpha = arma::as_scalar(U.col(i).t() * (Q * U.col(j)));
-      U.col(j) -= alpha * U.col(i);
-    }
-    double nrm2 = arma::as_scalar(U.col(j).t() * (Q * U.col(j)));
-    double nrm  = std::sqrt( std::max(tol, nrm2) );
-    if (nrm > tol) U.col(j) /= nrm;
-  }
-
-  // R-orthonormalize V (optional but helps comparisons)
-  arma::mat RdV = Rdense * V;
-  for (int j = 0; j < k_use; ++j) {
-    for (int i = 0; i < j; ++i) {
-      double alpha = std::as_const(arma::as_scalar(V.col(i).t() * RdV.col(j)));
-      V.col(j)  -= alpha * V.col(i);
-      RdV.col(j) -= alpha * RdV.col(i);
-    }
-    double nrm2 = arma::as_scalar(V.col(j).t() * (Rdense * V.col(j)));
-    double nrm  = std::sqrt( std::max(tol, nrm2) );
-    if (nrm > tol) {
-      V.col(j)  /= nrm;
-      RdV.col(j) /= nrm;
-    }
-  }
-
-  return Rcpp::List::create(
-    Rcpp::Named("u") = U,
-    Rcpp::Named("v") = V,
-    Rcpp::Named("d") = lam
-  );
-}
-
-// [[Rcpp::export]]
-Rcpp::List gmd_fast_cpp_dn(const arma::mat& X,
-                           const arma::mat& Q,
-                           const arma::mat& R,
-                           const int k,
-                           const double tol = 1e-8) {
-  return gmd_fast_impl(X, Q, R, k, tol);
-}
-
-// [[Rcpp::export]]
-Rcpp::List gmd_fast_cpp_sp(const arma::mat& X,
-                           const arma::sp_mat& Q,
-                           const arma::sp_mat& R,
-                           const int k,
-                           const double tol = 1e-8) {
-  return gmd_fast_impl(X, Q, R, k, tol);
-}
+// ---- helpers ---------------------------------------------------------------
+
+static inline arma::uvec topk_indices_desc(const arma::vec& eval, const int k) {
+  arma::uvec ord = arma::sort_index(eval, "descend");
+  return ord.head(k);
+}
+
+// Try ARPACK top-k; fall back to full eigen if unavailable.
+static bool eigs_topk(const arma::mat& M, const int k, arma::vec& eval, arma::mat& evec) {
+  if (k <= 0 || k >= (int)M.n_rows) return false;
+#ifdef ARMA_USE_ARPACK
+  try {
+    arma::eigs_sym(eval, evec, M, k, "la"); // largest algebraic
+    return true;
+  } catch (...) {
+    return false;
+  }
+#else
+  (void)M; (void)k; (void)eval; (void)evec;
+  return false;
+#endif
+}
+
+// Filter and sqrt eigenvalues -> singular values
+static arma::vec sqrt_pos(const arma::vec& x, const double tol) {
+  arma::vec y = x;
+  for (arma::uword i = 0; i < y.n_elem; ++i) {
+    y(i) = (y(i) > tol) ? std::sqrt(y(i)) : 0.0;
+  }
+  return y;
+}
+
+// ---- PRIMAL path (p <= n): needs Q and L_R (lower), returns scores/components ----
+template <typename MatQ>
+Rcpp::List gmd_primal_impl(const arma::mat& X,
+                           const MatQ& Q,
+                           const arma::mat& L_R,
+                           const int k,
+                           const double tol,
+                           const bool topk) {
+  const int p = (int)X.n_cols;
+  const int k_use = std::min(k, p);
+  // S = X' Q X
+  arma::mat S = X.t() * (Q * X);
+
+  // M = L_R^{-1} S L_R^{-T}
+  arma::mat Linv = arma::inv(arma::trimatl(L_R));
+  arma::mat M = Linv * S * Linv.t();
+
+  arma::vec eval;
+  arma::mat Z;
+  bool ok = false;
+  if (topk) ok = eigs_topk(M, k_use, eval, Z);
+  if (!ok) {
+    if (!arma::eig_sym(eval, Z, M)) Rcpp::stop("eig_sym failed (primal).");
+    arma::uvec ord = topk_indices_desc(eval, k_use);
+    Z = Z.cols(ord);
+    eval = eval.elem(ord);
+  }
+
+  arma::vec d = sqrt_pos(eval, tol);
+
+  // components C = R V = L_R^T Z
+  arma::mat C = L_R.t() * Z;                // p x k
+
+  // scores U = Q X C
+  arma::mat U = (Q * X) * C;                // n x k
+
+  return Rcpp::List::create(
+      Rcpp::Named("u") = U,
+      Rcpp::Named("v") = C,
+      Rcpp::Named("d") = d
+  );
+}
+
+// ---- DUAL path (n < p): needs L_Q (lower) and R, returns scores/components ----
+template <typename MatR>
+Rcpp::List gmd_dual_impl(const arma::mat& X,
+                         const arma::mat& L_Q,
+                         const MatR& R,
+                         const int k,
+                         const double tol,
+                         const bool topk) {
+  const int n = (int)X.n_rows;
+  const int k_use = std::min(k, n);
+
+  // B = L_Q^T X  (n x p)
+  arma::mat B = L_Q.t() * X;
+
+  // M = Q^{1/2} X R X^T Q^{1/2} = B R B^T  (n x n)
+  arma::mat RBt = R * B.t();             // (p x n)
+  arma::mat M   = B * RBt;               // (n x n)
+
+  arma::vec eval;
+  arma::mat Z;                           // Z = \tilde U (n x k)
+  bool ok = false;
+  if (topk) ok = eigs_topk(M, k_use, eval, Z);
+  if (!ok) {
+    if (!arma::eig_sym(eval, Z, M)) Rcpp::stop("eig_sym failed (dual).");
+    arma::uvec ord = topk_indices_desc(eval, k_use);
+    Z = Z.cols(ord);
+    eval = eval.elem(ord);
+  }
+  arma::vec d = sqrt_pos(eval, tol);     // singular values
+
+  // V = X^T (L_Q Z) / d   (p x k); Components C = R V
+  arma::mat LQZ = L_Q * Z;               // (n x k)
+  arma::mat Vtmp = X.t() * LQZ;          // (p x k)
+  for (int i = 0; i < (int)d.n_elem; ++i) {
+    if (d(i) > tol) Vtmp.col(i) /= d(i); else Vtmp.col(i).zeros();
+  }
+  arma::mat C = R * Vtmp;                // components = R V
+
+  // Scores U = Q X C = (L_Q L_Q^T) X C = L_Q * (L_Q^T X) * C = L_Q * B * C
+  arma::mat U = L_Q * (B * C);
+
+  return Rcpp::List::create(
+      Rcpp::Named("u") = U,
+      Rcpp::Named("v") = C,
+      Rcpp::Named("d") = d
+  );
+}
+
+// ---- Exported entry points -------------------------------------------------
+
+// Non-cached dense path: compute L_R / L_Q internally and dispatch primal/dual by size
+template <typename MatQ, typename MatR>
+Rcpp::List gmd_fast_auto(const arma::mat& X,
+                         const MatQ& Q,
+                         const MatR& R,
+                         const int k,
+                         const double tol,
+                         const bool topk) {
+  const int n = (int)X.n_rows;
+  const int p = (int)X.n_cols;
+  if (p <= n) {
+    arma::mat Rdense(R);
+    arma::mat L;
+    if (!arma::chol(L, Rdense, "lower")) Rcpp::stop("Cholesky of R failed.");
+    return gmd_primal_impl(X, Q, L, k, tol, topk);
+  } else {
+    arma::mat Qdense(Q);
+    arma::mat L;
+    if (!arma::chol(L, Qdense, "lower")) Rcpp::stop("Cholesky of Q failed.");
+    return gmd_dual_impl(X, L, R, k, tol, topk);
+  }
+}
+
+// [[Rcpp::export]]
+Rcpp::List gmd_fast_cpp_dn(const arma::mat& X,
+                           const arma::mat& Q,
+                           const arma::mat& R,
+                           const int k,
+                           const double tol = 1e-8,
+                           const bool topk = true) {
+  return gmd_fast_auto(X, Q, R, k, tol, topk);
+}
+
+// [[Rcpp::export]]
+Rcpp::List gmd_fast_cpp_sp(const arma::mat& X,
+                           const arma::sp_mat& Q,
+                           const arma::sp_mat& R,
+                           const int k,
+                           const double tol = 1e-8,
+                           const bool topk = true) {
+  return gmd_fast_auto(X, Q, R, k, tol, topk);
+}
+
+// Cached primal/dual entry points (dense L factors provided by R)
+// [[Rcpp::export]]
+Rcpp::List gmd_fast_cpp_primal_dn(const arma::mat& X,
+                                  const arma::mat& Q,
+                                  const arma::mat& L_R,
+                                  const int k,
+                                  const double tol = 1e-8,
+                                  const bool topk = true) {
+  return gmd_primal_impl(X, Q, L_R, k, tol, topk);
+}
+
+// [[Rcpp::export]]
+Rcpp::List gmd_fast_cpp_primal_sp(const arma::mat& X,
+                                  const arma::sp_mat& Q,
+                                  const arma::mat& L_R,
+                                  const int k,
+                                  const double tol = 1e-8,
+                                  const bool topk = true) {
+  return gmd_primal_impl(X, Q, L_R, k, tol, topk);
+}
+
+// [[Rcpp::export]]
+Rcpp::List gmd_fast_cpp_dual_dn(const arma::mat& X,
+                                const arma::mat& L_Q,
+                                const arma::mat& R,
+                                const int k,
+                                const double tol = 1e-8,
+                                const bool topk = true) {
+  return gmd_dual_impl(X, L_Q, R, k, tol, topk);
+}
+
+// [[Rcpp::export]]
+Rcpp::List gmd_fast_cpp_dual_sp(const arma::mat& X,
+                                const arma::mat& L_Q,
+                                const arma::sp_mat& R,
+                                const int k,
+                                const double tol = 1e-8,
+                                const bool topk = true) {
+  return gmd_dual_impl(X, L_Q, R, k, tol, topk);
+}
+
diff --git a/NAMESPACE b/NAMESPACE
index c1d2e3f..7d3f9ab 100644
--- a/NAMESPACE
+++ b/NAMESPACE
@@ -1,9 +1,16 @@
 # Generated by roxygen2: do not edit by hand
 
 export(genpca)
 export(gmd_fast_cpp)
+export(gmd_clear_cache)
 importFrom(stats, rnorm)
 import(Matrix)
 importFrom(methods, as)
+importFrom(digest, digest)
+
+useDynLib(genpca, .registration = TRUE)
+
+S3method(print, gmd_cache)  # harmless if not defined; roxygen may drop
 
diff --git a/DESCRIPTION b/DESCRIPTION
index 7c8d9e0..b2c3f10 100644
--- a/DESCRIPTION
+++ b/DESCRIPTION
@@ -8,13 +8,15 @@ Authors@R: c(
 )
 Description: Generalized PCA with row/column constraints.
 License: MIT + file LICENSE
 Depends: R (>= 3.6.0)
 Imports:
     Matrix (>= 1.5),
     methods,
     utils,
-    RSpectra,
-    Rcpp
+    RSpectra,
+    Rcpp,
+    digest
 LinkingTo:
     Rcpp,
     RcppArmadillo
 Suggests:
     testthat (>= 3.2.0),
     clue,
     knitr,
     rmarkdown
